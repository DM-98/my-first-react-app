0. Install Node.js
1. npx create-react-app [app name]
2. cd [app name]
3. npm start

Parent component: 
	- .JS (i.e.: App.js / MySecondPage.js) (imports child components)
Child component:
	- .JSX (i.e.: MyChildComponent.jsx) (exports itself) (HTML to JSX generator: https://transform.tools/html-to-jsx)

Thinking in React (https://beta.reactjs.org/learn/thinking-in-react):
	1. Break the UI into a component hierarchy
	2. Build a static version in React
	3. Find the minimal, but complete, representation of UI state
		- Identify a state:
			* Does it remain unchanged over time? If so, it isn’t state
			* Is it passed in from a parent via props? If so, it isn’t state
			* Can you compute it based on existing state or props in your component? If so, it definitely isn’t state
	4. Identify where your state should live
		- How to identify where each state should live in:
			1. Identify every component that renders something based on that state
			2. Find their closest common parent component — a component above them all in the hierarchy
			3. Decide where the state should live
				* Often, you can put the state directly into their common parent
				* You can also put the state into some component above their common parent
				* If you can’t find a component where it makes sense to own the state, 
				  create a new component solely for holding the state and add it somewhere in the hierarchy above the common parent component
	5. Add inverse data flow (two-way data binding)
		- function 'setVariableName' can be passed to its child component by adding a prop "onVariableNameChange"
			* i.e.: <MyChildComponent onVariableNameChange={setVariableName} /> 
			* in MyChildComponent: <input onChange={(event) => onVariableNameChange(event.target.value)} ... />

Hooks:
	* useState usage:
		- const [variableName, setVariableName] = useState[startValue];
	* useEffect usage:
		- useEffect(lambda-expression, [variableName]); // calls lambda-expression(arrow function) everytime variableName is changed
		- useEffect(lambda-expression, []); 		// calls lambda-expression only once (dependency (empty) array), in this case: at page load
		- useEffect(lambda-expression); 			// calls lambda-expression everytime an event has occurred; page load/button click/etc.
	* useImmer usage (install needed; third party package):
		- const [variableName, updateVariableName] = useImmer[startValue]; // Copies(draft) old values to its autogenerated copy and sets the new state
			* Immer: https://beta.reactjs.org/learn/updating-objects-in-state#write-concise-update-logic-with-immer

JSX Markup notes:
	* {{ some = data, more = data }} -> Just an object inside a JSX
	* style properties are written in camelCase in JSX
		- i.e.: <ul style="background-color: black"> should be: <ul style={{ backgroundColor: 'black' }}> (Tip: use generator)
	* A JS(X) object can contain an object property (i.e. person-object has a theme-object that contains style properties to be applied in style={person.theme})

Destructuring props:
	- function (props) { props.propertyName } -> function ({ nameOfVariable }) { nameOfVariable.propertyName }
Forwarding props (spread syntax) - eliminates repetiveness:
	- function ({ person, size, isSepia, thickBorder }) { person={person}, size={size}, etc. } -> function (props) {...props} (props can be the deconstructuring variable name)

Eliminate code repetiveness when updating objects/arrays:
	- useImmer instead of useState for updating objects/arrays in state (setVariableName) becomes (updateVariableName)
	- Usage example: https://beta.reactjs.org/learn/adding-interactivity#updating-arrays-in-state

Event handlers must be passed, not called:
	- <button onClick={alert('You clicked me!')}> -> Calls the alert-function on component rendering (code executes on page load) (Bad)
	- <button onClick={() => alert('You clicked me!')}> -> Executes the code only when clicked and not on rendering (Good)
		* Same, but easier, example:
			- <button onClick={handleClick()} /> (Bad)
			- <button onClick={handleClick} (Good)

Event propagation (on-handlers, i.e.c onClick):
	- If you have a <button> inside <div> and the <div> & <button> both have an onClick event handler, both fire by default
	- To prevent this propagation: 
		* In most scenarios you want <button> only, not <div> too; in button even handler: e.stopPropagation(); then onClick();
 	- Capture events (but not in app code) for routing/analytics/logging
		* In your <div>, instead of onClick, you should use onClickCapture={() => ...}

Prevent default behavior:
	- Browser events often reload pages when clicking a <button> that's inside of a <form>
	- Same logic as preventing propagation is applied, but e.preventDefault(); should be used instead (now page won't refresh when button is clicked)

Rendering in React:
	1. Trigger
		- A trigger happens when app starts (typically happens in index.js @ ReactDOM.render(...))
		- When setVariableName occur (state update)
	2. Render
		- React renders the root component at app start
		- React renders the specific component where state is located at and its child components
			* Note: Performance is degrades more when state is located high in the tree, and state is used in many child components
	3. Commit 
		- At initial render; React uses the appendChild() DOM API to put all the DOM nodes it has created onto the screen
		- At re-renders; React will apply minimal necessary operations (calculated during rendering) to the specific component DOMs

State as a Snapshot:
	- The variable 'number' (initially set to 0), running a function like this: 
		* setNumber(number + 5); alert(number); => outputs 0, because these are in the same event (snapshot) and hasn't finished the results until the end
		* The snapshot looks like this: setNumber(0 + 5); alert(0);
	- React waits until all code in the event handlers has run before processing your state updates

Queueing a series of state updates:
	- Setting a state variable will queue another render. Before rendering, you might want to set(update) a series of state changes
	- Snapshot example fix: setNumber(n => n + 5); alert(number + 5);
		* Note: Here we create an update function that tells React to take the return of the last update function value, and put it in 'number'
		* Note about alert: We add + 5, since the queue was stopped at the update function setNumber(n => n + 5) and the event is still running
		* Better examples: https://beta.reactjs.org/learn/queueing-a-series-of-state-updates

Updating objects in state:
	- You should not change objects that you hold directly, instead copy the existing one/or create a new, delete the old, and use the new one (copy)
	- setVariableName(new string-value or new number-value or new boolean-value, etc) replaces the state variable value, not updating it (they are immutable)
	- objects in the other hand, are mutable, i.e.: myObjectVariable.propertA = 5. But React doesn't know the state has changed
	- You should consider objects as immutable and always replace them such as: setMyObjectVariable(myUpdatedObjectVariable); - now React knows and updates DOM
	* Note: Object spread syntax works; https://beta.reactjs.org/learn/updating-objects-in-state#copying-objects-with-the-spread-syntax

Updating arrays in state:
	- Check above section, same applies
	- (Table) Good&Bad todos with updating/sorting/adding/removing arrays: 
		* https://beta.reactjs.org/learn/updating-arrays-in-state#updating-arrays-without-mutation
